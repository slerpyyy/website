<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Würfelblitz | This is slerpy</title><meta name=keywords content="demoscene,256b,intro"><meta name=description content="a 256b PC intro released at Revision 2021
[pouët]
This intro is a demonstration of a way to simulate buffer swaps using special color values, all within 256 bytes.
The naive way to render an effect like this would be to first clear the entire screen, then draw some lines and repeat. This works in theory but it creates a lot of flickering since you're very likely to see the image while it's in the middle of either clearing or rendering, meaning the lines are only partially visible."><meta name=author content><link rel=canonical href=https://slerpy.xyz/posts/wuerfelblitz/><link crossorigin=anonymous href=/assets/css/stylesheet.7cea68b77c83e5da57c9a11c56919d4de2e6847751854f818c1d6aeb21f21f85.css integrity="sha256-fOpot3yD5dpXyaEcVpGdTeLmhHdRhU+BjB1q6yHyH4U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://slerpy.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://slerpy.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://slerpy.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://slerpy.xyz/apple-touch-icon.png><link rel=mask-icon href=https://slerpy.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Würfelblitz"><meta property="og:description" content="a 256b PC intro released at Revision 2021
[pouët]
This intro is a demonstration of a way to simulate buffer swaps using special color values, all within 256 bytes.
The naive way to render an effect like this would be to first clear the entire screen, then draw some lines and repeat. This works in theory but it creates a lot of flickering since you're very likely to see the image while it's in the middle of either clearing or rendering, meaning the lines are only partially visible."><meta property="og:type" content="article"><meta property="og:url" content="https://slerpy.xyz/posts/wuerfelblitz/"><meta property="og:image" content="https://slerpy.xyz/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-06T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-06T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://slerpy.xyz/papermod-cover.png"><meta name=twitter:title content="Würfelblitz"><meta name=twitter:description content="a 256b PC intro released at Revision 2021
[pouët]
This intro is a demonstration of a way to simulate buffer swaps using special color values, all within 256 bytes.
The naive way to render an effect like this would be to first clear the entire screen, then draw some lines and repeat. This works in theory but it creates a lot of flickering since you're very likely to see the image while it's in the middle of either clearing or rendering, meaning the lines are only partially visible."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://slerpy.xyz/posts/"},{"@type":"ListItem","position":2,"name":"Würfelblitz","item":"https://slerpy.xyz/posts/wuerfelblitz/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Würfelblitz","name":"Würfelblitz","description":"a 256b PC intro released at Revision 2021\n[pouët]\nThis intro is a demonstration of a way to simulate buffer swaps using special color values, all within 256 bytes.\nThe naive way to render an effect like this would be to first clear the entire screen, then draw some lines and repeat. This works in theory but it creates a lot of flickering since you're very likely to see the image while it's in the middle of either clearing or rendering, meaning the lines are only partially visible.","keywords":["demoscene","256b","intro"],"articleBody":"a 256b PC intro released at Revision 2021\n[pouët]\nThis intro is a demonstration of a way to simulate buffer swaps using special color values, all within 256 bytes.\nThe naive way to render an effect like this would be to first clear the entire screen, then draw some lines and repeat. This works in theory but it creates a lot of flickering since you're very likely to see the image while it's in the middle of either clearing or rendering, meaning the lines are only partially visible.\nMy initial idea to get around this was to allocate a back buffer so I could first render the image off-screen and then copy the complete image onto the screen, but after some experimentation, I determined this was not going to fit into 256 bytes.\nWhat I found out is that the default MS-Dos color palette has two different codes for both black and white, which conveniently differ by just 1 bit each. That bit can be used to encode what color each pixel should have in the next frame without visibly changing the image.\nSo when drawing the lines, it walks along each line and sets this bit for every pixel on the way. After that, it iterates over all pixels on the screen and replaces them with (the lower variation of) either black or white depending on whether or not the bit was set.\nThe result is a perfectly flicker-free animation since from the outside, it looks like it just sweep-transitions from one frame to the next with no intermediate stages in between.\nI did realize after the compo that I could have implemented the same effect by clearing the screen, drawing the lines and waiting for a couple of milliseconds and it would have been 99.99% flicker-free because of how fast the first two steps are, but oh well...\n","wordCount":"310","inLanguage":"en","datePublished":"2021-04-06T00:00:00Z","dateModified":"2021-04-06T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://slerpy.xyz/posts/wuerfelblitz/"},"publisher":{"@type":"Organization","name":"This is slerpy","logo":{"@type":"ImageObject","url":"https://slerpy.xyz/favicon.ico"}}}</script><style>#molivebuds{margin:0 auto;padding:15px}#molivebuds table{background-color:var(--entry);margin:0 auto;border-radius:var(--radius)}#molivebuds table tr td{padding:15px}#molivebuds .webring-prev{text-align:right}#molivebuds .webring-info{text-align:center}#molivebuds .webring-next{text-align:left}#molivebuds .webring-links{font-size:small}</style></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://slerpy.xyz/ accesskey=h title="This is slerpy (Alt + H)">This is slerpy</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://slerpy.xyz/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://slerpy.xyz/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://slerpy.xyz/contact/ title=Contact><span>Contact</span></a></li><li><a href=https://slerpy.xyz/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://slerpy.xyz/legacy/ title=Legacy><span>Legacy</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://slerpy.xyz/>Home</a>&nbsp;»&nbsp;<a href=https://slerpy.xyz/posts/>Posts</a></div><h1 class=post-title>Würfelblitz</h1><div class=post-meta><span title='2021-04-06 00:00:00 +0000 UTC'>April 6, 2021</span>&nbsp;·&nbsp;2 min</div></header><div class=post-content><p>a 256b PC intro released at Revision 2021</p><p><img loading=lazy src=/wuerfelblitz/final.png alt=image></p><p>[<a href="https://www.pouet.net/prod.php?which=88534">pouët</a>]</p><p>This intro is a demonstration of a way to simulate buffer swaps using special color values, all within 256 bytes.</p><p>The naive way to render an effect like this would be to first clear the entire screen, then draw some lines and repeat.
This works in theory but it creates a lot of flickering since you're very likely to see the image while it's in the middle of either clearing or rendering, meaning the lines are only partially visible.</p><p>My initial idea to get around this was to allocate a back buffer so I could first render the image off-screen and then copy the complete image onto the screen, but after some experimentation, I determined this was not going to fit into 256 bytes.</p><p>What I found out is that the default MS-Dos color palette has two different codes for both black and white, which conveniently differ by just 1 bit each.
That bit can be used to encode what color each pixel should have in the next frame without visibly changing the image.</p><p><img loading=lazy src=/wuerfelblitz/palette.png alt=image></p><p>So when drawing the lines, it walks along each line and sets this bit for every pixel on the way.
After that, it iterates over all pixels on the screen and replaces them with (the lower variation of) either black or white depending on whether or not the bit was set.</p><p>The result is a perfectly flicker-free animation since from the outside, it looks like it just sweep-transitions from one frame to the next with no intermediate stages in between.</p><hr><p>I did realize after the compo that I could have implemented the same effect by clearing the screen, drawing the lines and waiting for a couple of milliseconds and it would have been 99.99% flicker-free because of how fast the first two steps are, but oh well...</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://slerpy.xyz/tags/demoscene/>demoscene</a></li><li><a href=https://slerpy.xyz/tags/256b/>256b</a></li><li><a href=https://slerpy.xyz/tags/intro/>intro</a></li></ul><nav class=paginav><a class=prev href=https://slerpy.xyz/posts/off-by-one/><span class=title>« Prev</span><br><span>Off by One</span></a>
<a class=next href=https://slerpy.xyz/posts/tesseract/><span class=title>Next »</span><br><span>Tesseract</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://slerpy.xyz/>This is slerpy</a></span>
-
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>