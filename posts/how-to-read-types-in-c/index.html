<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to Read Types in C | This is slerpy</title><meta name=keywords content><meta name=description content="Type signatures in C are a common point of confusion for even seasoned programmers. I found myself repeating the same explanations over and over again, so I decided to write this post to have a reference to link to.
Recap: Type annotations In many programming languages (and in mathematics), you annotate an expression e with type A by writing e : A. These types can either be primitive types like int or float, or they can be compound types like function types A → B or product types A × B (aka tuples (A, B))."><meta name=author content><link rel=canonical href=https://slerpy.xyz/posts/how-to-read-types-in-c/><link crossorigin=anonymous href=/assets/css/stylesheet.7cea68b77c83e5da57c9a11c56919d4de2e6847751854f818c1d6aeb21f21f85.css integrity="sha256-fOpot3yD5dpXyaEcVpGdTeLmhHdRhU+BjB1q6yHyH4U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://slerpy.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://slerpy.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://slerpy.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://slerpy.xyz/apple-touch-icon.png><link rel=mask-icon href=https://slerpy.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="How to Read Types in C"><meta property="og:description" content="Type signatures in C are a common point of confusion for even seasoned programmers. I found myself repeating the same explanations over and over again, so I decided to write this post to have a reference to link to.
Recap: Type annotations In many programming languages (and in mathematics), you annotate an expression e with type A by writing e : A. These types can either be primitive types like int or float, or they can be compound types like function types A → B or product types A × B (aka tuples (A, B))."><meta property="og:type" content="article"><meta property="og:url" content="https://slerpy.xyz/posts/how-to-read-types-in-c/"><meta property="og:image" content="https://slerpy.xyz/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-24T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-24T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://slerpy.xyz/papermod-cover.png"><meta name=twitter:title content="How to Read Types in C"><meta name=twitter:description content="Type signatures in C are a common point of confusion for even seasoned programmers. I found myself repeating the same explanations over and over again, so I decided to write this post to have a reference to link to.
Recap: Type annotations In many programming languages (and in mathematics), you annotate an expression e with type A by writing e : A. These types can either be primitive types like int or float, or they can be compound types like function types A → B or product types A × B (aka tuples (A, B))."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://slerpy.xyz/posts/"},{"@type":"ListItem","position":2,"name":"How to Read Types in C","item":"https://slerpy.xyz/posts/how-to-read-types-in-c/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to Read Types in C","name":"How to Read Types in C","description":"Type signatures in C are a common point of confusion for even seasoned programmers. I found myself repeating the same explanations over and over again, so I decided to write this post to have a reference to link to.\nRecap: Type annotations In many programming languages (and in mathematics), you annotate an expression e with type A by writing e : A. These types can either be primitive types like int or float, or they can be compound types like function types A → B or product types A × B (aka tuples (A, B)).","keywords":[],"articleBody":"Type signatures in C are a common point of confusion for even seasoned programmers. I found myself repeating the same explanations over and over again, so I decided to write this post to have a reference to link to.\nRecap: Type annotations In many programming languages (and in mathematics), you annotate an expression e with type A by writing e : A. These types can either be primitive types like int or float, or they can be compound types like function types A → B or product types A × B (aka tuples (A, B)).\nHere are some examples of valid type annotations:\n2 : int 3.14 : float square : int → int square(2) : int Many languages also feature generic types, which are types that can be parameterized by other types. For example, the type List is a list of elements of type A. You can think of these as being \"functions\" from types to types (e.g. List takes a type A and returns a type List).\nIn the following, we will also see pointer types ptr (often denoted with a *), and arrays array (often denoted with []), where N is the size of the array.\nHow C does it In C, the syntax used to declare variables mirrors the syntax of their usage. While it probably felt intuitive at the time, this \"declaration follows usage\" principle effectively means you spell the type inside out.\nMore precisely, a declaration in C consists of some declaration specifiers (these include type specifiers such as int or float, but also things like const, static, inline, etc.) followed by a list of declarators. A declarator is essentially an identifier with some simple operations (e.g. dereferencing *, indexing [], function application (..), etc.) applied to it. The declaration specifiers tell you the type of the result of those operations on the identifier.\nint x declares x to be type int. float *x declares *x to be type float, i.e. x : ptr int *x[10] declares *x[10] to be type int, i.e. x : array","wordCount":"1100","inLanguage":"en","datePublished":"2024-01-24T00:00:00Z","dateModified":"2024-01-24T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://slerpy.xyz/posts/how-to-read-types-in-c/"},"publisher":{"@type":"Organization","name":"This is slerpy","logo":{"@type":"ImageObject","url":"https://slerpy.xyz/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://slerpy.xyz/ accesskey=h title="This is slerpy (Alt + H)">This is slerpy</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://slerpy.xyz/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://slerpy.xyz/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://slerpy.xyz/contact/ title=Contact><span>Contact</span></a></li><li><a href=https://slerpy.xyz/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://slerpy.xyz/legacy/ title=Legacy><span>Legacy</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://slerpy.xyz/>Home</a>&nbsp;»&nbsp;<a href=https://slerpy.xyz/posts/>Posts</a></div><h1 class=post-title>How to Read Types in C</h1><div class=post-meta><span title='2024-01-24 00:00:00 +0000 UTC'>January 24, 2024</span>&nbsp;·&nbsp;6 min</div></header><div class=post-content><p>Type signatures in C are a common point of confusion for even seasoned programmers.
I found myself repeating the same explanations over and over again, so I decided to write this post to have a reference to link to.</p><h2 id=recap-type-annotations>Recap: Type annotations<a hidden class=anchor aria-hidden=true href=#recap-type-annotations>#</a></h2><p>In many programming languages (and in mathematics), you annotate an expression <code>e</code> with type <code>A</code> by writing <code>e : A</code>. These types can either be primitive types like <code>int</code> or <code>float</code>, or they can be compound types like function types <code>A → B</code> or product types <code>A × B</code> (aka tuples <code>(A, B)</code>).</p><p>Here are some examples of valid type annotations:</p><ul><li><code>2 : int</code></li><li><code>3.14 : float</code></li><li><code>square : int → int</code></li><li><code>square(2) : int</code></li></ul><p>Many languages also feature generic types, which are types that can be parameterized by other types. For example, the type <code>List&lt;A></code> is a list of elements of type <code>A</code>. You can think of these as being "functions" from types to types (e.g. <code>List</code> takes a type <code>A</code> and returns a type <code>List&lt;A></code>).</p><p>In the following, we will also see pointer types <code>ptr&lt;A></code> (often denoted with a <code>*</code>), and arrays <code>array&lt;A, N></code> (often denoted with <code>[]</code>), where <code>N</code> is the size of the array.</p><h2 id=how-c-does-it>How C does it<a hidden class=anchor aria-hidden=true href=#how-c-does-it>#</a></h2><p>In C, the syntax used to declare variables mirrors the syntax of their usage.
While it probably felt intuitive at the time, this "declaration follows usage" principle effectively means you spell the type inside out.</p><p>More precisely, a declaration in C consists of some declaration specifiers (these include type specifiers such as <code>int</code> or <code>float</code>, but also things like <code>const</code>, <code>static</code>, <code>inline</code>, etc.) followed by a list of declarators. A declarator is essentially an identifier with some simple operations (e.g. dereferencing <code>*</code>, indexing <code>[]</code>, function application <code>(..)</code>, etc.) applied to it. <strong>The declaration specifiers tell you the type of the <em>result</em> of those operations on the identifier.</strong></p><ul><li><code>int x</code> declares <code>x</code> to be type <code>int</code>.</li><li><code>float *x</code> declares <code>*x</code> to be type <code>float</code>, i.e. <code>x : ptr&lt;float></code></li><li><code>int *x[10]</code> declares <code>*x[10]</code> to be type <code>int</code>, i.e. <code>x : array&lt;ptr&lt;int>, 10></code></li><li><code>int (*x)[10]</code> declares <code>(*x)[10]</code> to be type <code>int</code>, i.e. <code>x : ptr&lt;array&lt;int, 10>></code></li><li><code>float f(int x)</code> declares <code>f(x)</code> to be type <code>float</code>, i.e. <code>f : int → float</code></li><li><code>void *f(int x)</code> declares <code>f : int → ptr&lt;void></code></li><li><code>void (*(*f)(int x))(float y)</code> declares <code>f : ptr&lt;int → ptr&lt;float → void>></code></li></ul><p>I find that even in university-level courses, this is often glossed over, leaving students to <em>figure it out on their own</em>, often by looking at some examples. Many end up with the mental model that declarations are just a type followed by a variable name, which works for annoyingly many cases, but breaks for <em>just slightly</em> more complicated ones.</p><p>A by now relatively famous example is <code>int* x, y;</code>.
At first sight it might look like we are declaring two pointers, but in reality, this declares both <code>*x</code> and <code>y</code> to be type <code>int</code>, meaning <code>x : ptr&lt;int></code> and <code>y : int</code>.
Of course, you can make this more explicit by moving the <code>*</code> to the right, or by using parentheses (like <code>int (*x), y;</code>) but rarely anyone does.</p><h3 id=an-evaluation-algorithm-for-c-declarations>An evaluation algorithm for C declarations<a hidden class=anchor aria-hidden=true href=#an-evaluation-algorithm-for-c-declarations>#</a></h3><p>The translation from a C declaration to its type can be defined recursively.</p><p>A declaration of the form <code>T D</code>, where <code>T</code> is a type specifier and <code>D</code> is the declarator, has type <code>τ(D, T)</code> where <code>τ</code> is defined recursively as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>τ</span>(<span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>T</span>)           <span style=color:#f92672>=</span> <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>τ</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>D</span>, <span style=color:#a6e22e>T</span>)           <span style=color:#f92672>=</span> <span style=color:#a6e22e>τ</span>(<span style=color:#a6e22e>D</span>, <span style=color:#a6e22e>ptr</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>τ</span>(<span style=color:#a6e22e>D</span>[<span style=color:#a6e22e>N</span>], <span style=color:#a6e22e>T</span>)         <span style=color:#f92672>=</span> <span style=color:#a6e22e>τ</span>(<span style=color:#a6e22e>D</span>, <span style=color:#a6e22e>array</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>N</span><span style=color:#f92672>&gt;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>τ</span>(<span style=color:#a6e22e>D</span>(<span style=color:#a6e22e>T</span><span style=color:#e6db74>&#39; S&#39;</span>, ..), <span style=color:#a6e22e>T</span>) <span style=color:#f92672>=</span> <span style=color:#a6e22e>τ</span>(<span style=color:#a6e22e>D</span>, (<span style=color:#a6e22e>τ</span>(<span style=color:#a6e22e>T</span><span style=color:#e6db74>&#39; S&#39;</span>), ..) <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>T</span>)
</span></span></code></pre></div><p>Here are some examples of how this works.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// int *x[4];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>τ</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>x</span>[<span style=color:#ae81ff>4</span>], <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>=</span> <span style=color:#a6e22e>τ</span>(<span style=color:#a6e22e>x</span>[<span style=color:#ae81ff>4</span>], <span style=color:#a6e22e>ptr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>=</span> <span style=color:#a6e22e>τ</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>array</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>ptr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, <span style=color:#ae81ff>4</span><span style=color:#f92672>&gt;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>=</span> <span style=color:#a6e22e>array</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>ptr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, <span style=color:#ae81ff>4</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// void *f(int *x)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>τ</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>x</span>), <span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>=</span> <span style=color:#a6e22e>τ</span>(<span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>x</span>), <span style=color:#a6e22e>ptr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>=</span> <span style=color:#a6e22e>τ</span>(<span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>τ</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>x</span>, <span style=color:#66d9ef>int</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>ptr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>=</span> <span style=color:#a6e22e>τ</span>(<span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>τ</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>ptr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>ptr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>=</span> <span style=color:#a6e22e>τ</span>(<span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>ptr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>ptr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>=</span> <span style=color:#a6e22e>ptr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>ptr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><h3 id=type-names>Type names<a hidden class=anchor aria-hidden=true href=#type-names>#</a></h3><p>In some cases, you just want to name a type without also declaring a variable.
To do this, you can use a type name.
They look almost exactly like the declarations we have seen already with the identifier removed.
So instead of <code>int *x</code>, you would write <code>int *</code>, or <code>int (*)</code> if you want to be pedantic.</p><p>Here are some examples of type names:</p><ul><li><code>char *</code> represents <code>ptr&lt;char></code></li><li><code>int (*)[3]</code> represents <code>ptr&lt;array&lt;int, 3>></code></li><li><code>int *()</code> represents <code>() → ptr&lt;int></code> <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li><li><code>int (*)(float)</code> represents <code>ptr&lt;float → int></code></li><li><code>void *(*)(int)</code> represents <code>ptr&lt;int → ptr&lt;void>></code></li></ul><p>I'm not sure this still counts as "declaration follows usage" since there is nothing to be used here, but the syntax is still consistent with the declaration syntax, so I think it's a reasonable choice.</p><h3 id=what-about-typedef>What about <code>typedef</code>?<a hidden class=anchor aria-hidden=true href=#what-about-typedef>#</a></h3><p>Some of you might know that the <code>int* x, y;</code> problem can be solved by introducing a type alias, as follows.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> <span style=color:#66d9ef>int_ptr_t</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int_ptr_t</span> x, y;
</span></span></code></pre></div><p>This will indeed declare both <code>x</code> and <code>y</code> with type <code>int_ptr_t = ptr&lt;int></code>.
So what's going on here? Well, the first line is really just another declaration.
<code>typedef</code> is a storage-class specifier, so it is one of the declaration specifiers we mentioned earlier.
Fully parenthesized, the first line becomes <code>typedef int (*(int_ptr_t));</code>.
So, a declaration like <code>int_ptr_t x;</code> is expanded by substituting <code>int_ptr_t</code> for our declarator <code>x</code> in the type definition, so we get <code>int (*(x));</code>.</p><h3 id=the-curious-case-of-c>The curious case of C++<a hidden class=anchor aria-hidden=true href=#the-curious-case-of-c>#</a></h3><p>Since C++ is (mostly) backward compatible with C, declarations in C++ also spell the type inside out, <em>but</em> C++ also has templated types, which are spelled outside in.</p><p>For example, the declaration <code>std::vector&lt;int (*)[6]> *v;</code> would declare a variable <code>v</code> of type <code>ptr&lt;vector&lt;ptr&lt;array&lt;int, 6>>>></code>.
Here is an illustration of the order in which you read the declaration.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>)[<span style=color:#ae81ff>6</span>]<span style=color:#f92672>&gt;</span> <span style=color:#f92672>*</span>v;
</span></span><span style=display:flex><span>     <span style=color:#f92672>^</span>       <span style=color:#f92672>^</span>   <span style=color:#f92672>^</span>  <span style=color:#f92672>^</span>   <span style=color:#f92672>^</span>
</span></span><span style=display:flex><span>     <span style=color:#ae81ff>2</span>       <span style=color:#ae81ff>5</span>   <span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>In fact, C++ templates can be used to "reverse" the order of declarations arbitrarily, using an identity template.
In the following, all declarations of <code>f : array&lt;ptr&lt;int → float>, 2></code> are equivalent.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>using</span> Id <span style=color:#f92672>=</span> T;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> (<span style=color:#f92672>*</span>f[<span style=color:#ae81ff>2</span>])(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>Id<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span> (<span style=color:#f92672>*</span>f[<span style=color:#ae81ff>2</span>])(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>Id<span style=color:#f92672>&lt;</span>Id<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>int</span>)<span style=color:#f92672>&gt;</span> <span style=color:#f92672>*</span>f[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>Id<span style=color:#f92672>&lt;</span>Id<span style=color:#f92672>&lt;</span>Id<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>int</span>)<span style=color:#f92672>&gt;*&gt;</span> f[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>Id<span style=color:#f92672>&lt;</span>Id<span style=color:#f92672>&lt;</span>Id<span style=color:#f92672>&lt;</span>Id<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>int</span>)<span style=color:#f92672>&gt;*&gt;</span>[<span style=color:#ae81ff>2</span>]<span style=color:#f92672>&gt;</span> f;
</span></span></code></pre></div><p>We can make this look a little nicer by adding more type aliases.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>using</span> Ptr <span style=color:#f92672>=</span> T<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>int</span> N<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>using</span> Array <span style=color:#f92672>=</span> T[N];
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>typename</span>... Args<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>using</span> Fn <span style=color:#f92672>=</span> T(Args...);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Array<span style=color:#f92672>&lt;</span>Ptr<span style=color:#f92672>&lt;</span>Fn<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>, <span style=color:#ae81ff>2</span><span style=color:#f92672>&gt;</span> g;
</span></span></code></pre></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>In C, if a function is declared with an empty parameter list, it means that the number and types of the parameters are unspecified. This is different from a function with no parameters, which is declared with <code>void</code> as the parameter list. In C++, an empty parameter list means no parameters.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://slerpy.xyz/posts/new-website/><span class=title>Next »</span><br><span>New Website!</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://slerpy.xyz/>This is slerpy</a></span>
-
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>